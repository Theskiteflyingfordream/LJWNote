索引是帮助MySQL高效获取数据的数据结构。一般用B+树实现。

#### 计算机存取原理

- 页的概念：

​		页是计算机管理存储器的逻辑块，硬件及操作系统往往将主存和磁盘存储区分割为连续的大小相等的块，每个存储块称为一页（在许		多操作系统中，页得大小通常为4k），主存和磁盘以页为单位交换数据。当程序要读取的数据不在主存中时，会触发一个缺页异常，		此时系统会向磁盘发出读盘信号，磁盘会找到数据的起始位置并向后连续读取一页或几页载入内存中，然后异常返回，程序继续运	  		行；	

​		索引中一个结点大小一般为一个页，这样一次IO就能读取整个结点；

- 主存存取原理：

![5](用到的图片/5.png)

​		主存存取的时间仅与存取次数呈线性关系，因为不存在机械操作，两次存取的数据的“距离”不会对时间有任何影响，例如，先取A0再取A1和先取A0再取D3的时间消耗是一样的。

- 磁盘存取原理：

​		寻道+旋转+读取；机械运动十分耗时；

​		根据局部性原理，磁盘往往不是严格按需读取，而是每次都会预读，预读的长度一般为页（page）的整倍数。

#### B树与B+树：

​	[漫画：什么是B+树？ - 知乎 (zhihu.com)](https://zhuanlan.zhihu.com/p/54102723)

​	B+树优势：

​		1.由于非叶子结点不存data，因此能够存更多的被索引字段，这使得整棵树更矮更胖，减少了IO次数。

​		2.所有的查询最终都会到达叶子结点，性能稳定。

​		3.所有叶子结点形成有序链表，相对B树更利于范围查询。

#### 为什么不用红黑树或者hash？

​	用红黑树会导致树更高，使得IO次数增加，查询效率变慢；而使用B/B+树适用于外部排序，每个结点可以存放一个磁盘块的数据，这样一次IO就能把整个结点读进来；

​	用hash时，每插入一个元素会把我们的索引字段做一次hash计算，把运算的到的结果值和这一行的所在磁盘	地址做一个映射；虽然	hash的等值查询十分快，但是其对范围查询支持十分弱。

#### 索引的查询过程：

​	索引往往以索引文件的形式存储的磁盘上，索引查找过程中要产生磁盘I/O消耗；

​	首先将根结点读入内存中，比较后找到下一个结点，再将下一个结点读入内存。。。。

#### MyISAM与InnoDB索引实现的区别

- MyISAM索引文件和数据文件是分离的；

  而InnoDB的数据文件本身就是索引文件，其按照主键进行索引，如下，叶节点包含了完整的数据记录，这种索引叫做聚集索引：

![10](用到的图片/10.png)

​			

- MyISAM索引中的data域是数据记录的地址；

  而InnoDB的所有辅助索引（即除主键外）都引用主键作为data域

​		MyISAM的索引：

![9](用到的图片/9.png)

​		InnoDB的辅助索引：

![11](用到的图片/11.png)

​	因为InnoDB的数据文件本身要按主键聚集，所以InnoDB要求表必须有主键（MyISAM可以没有），如果没有	显式指定，则MySQL系统会自动选择一个可以唯一标识数据记录的列作为主键，如果不存在这种列，则  	 	 	MySQL自动为InnoDB表生成一个隐含字段作为主键，这个字段长度为6个字节，类型为长整形。

#### 联合索引的示意图：

![bcd联合索引在B+树上的结构图](https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/2/27/170867cb6af0a72d~tplv-t2oaga2asx-watermark.awebp)

#### 索引的优化策略	

​	索引虽然可以加快查询，但是索引文件本身要消耗存储空间，同时索引会加重插入、删除和修改记录时的负担，另外，MySQL在运行时也要消耗资源维护索引，因此索引并不是越多越好。当表记录比较少或者索引的选择性较低（索引的选择性是指不重复的索引值与表记录数的比值）时，不建议建立索引；

​	前缀索引：用列的前缀代替整个列作为索引key，当前缀长度合适时，可以做到既使得前缀索引的选择性接近	全列索引，同时因为索引key变短而减少了索引文件的大小和维护开销。

#### InnoDB的主键选择

建议使用与业务无关的自增主键，原因：

同一个叶子节点内（大小为一个内存页或磁盘页）的各条数据记录按主键顺序存放，因此每当有一条新的记录插入时，MySQL会根据其主键将其插入适当的节点和位置，如果页面达到装载因子则开辟一个新的页（节点）。

如果表使用自增主键，那么每次插入新的记录，记录就会顺序添加到当前索引节点的后续位置，当一页写满，就会自动开辟一个新的页。这样就会形成一个紧凑的索引结构，近似顺序填满，而且每次插入时也不需要移动已有数据，因此效率很高，也不会增加很多开销在维护索引上。

如果使用非自增主键（如果身份证号或学号等），由于每次插入主键的值近似于随机，因此每次新纪录都要被插到现有索引页得中间某个位置：此时MySQL不得不为了将新记录插到合适位置而移动数据，甚至目标页面可能已经被回写到磁盘上而从缓存中清掉，此时又要从磁盘上读回来，这增加了很多开销，同时频繁的移动、分页操作造成了大量的碎片，得到了不够紧凑的索引结构，后续不得不通过OPTIMIZE TABLE来重建表并优化填充页面。



#### 参考：

[CodingLabs - MySQL索引背后的数据结构及算法原理](http://blog.codinglabs.org/articles/theory-of-mysql-index.html)

[MySQL索引那些事 (qq.com)](https://mp.weixin.qq.com/s?__biz=MzUxNTQyOTIxNA==&mid=2247484041&idx=1&sn=76d3bf1772f9e3c796ad3d8a089220fa&chksm=f9b784b8cec00dae3d52318f6cb2bdee39ad975bf79469b72a499ceca1c5d57db5cbbef914ea&token=2025456560&lang=zh_CN#rd)

（上面两篇以第一篇为主）

[MySQL索引底层实现原理 - 做个有梦想的咸鱼 - 博客园 (cnblogs.com)](https://www.cnblogs.com/boothsun/p/8970952.html)

（近似第一篇的前面部分）

[联合索引在B+树上的存储结构及数据查找方式 - 掘金 (juejin.cn)](https://juejin.cn/post/6844904073955639304)


##### JVM vs JDK vs JRE

Java 虚拟机是运行 Java 字节码的虚拟机。JVM 有针对不同系统的特定实现，目的是使用相同的字节码，它们都会给出相同的结果。

JRE 是 Java 运行时环境。它是运行已编译 Java 程序所需的所有内容的集合，包括 Java 虚拟机（JVM），Java 类库，java 命令和其他的一些基础构件。但是，它不能用于创建新程序。

JDK拥有 JRE 所拥有的一切，还有编译器（javac）和工具（如 javadoc 和 jdb）。它能够创建和编译程序。



##### 什么是字节码-采用字节码的好处是什么

JVM 可以理解的代码就叫做字节码，它不面向任何特定的处理器，只面向虚拟机。Java 语言通过字节码的方式，在一定程度上解决了传统解释型语言执行效率低的问题，同时又保留了解释型语言可移植的特点。 Java 程序无须重新编译便可在多种不同操作系统的计算机上运行。



##### 为什么说 Java 语言“编译与解释并存”？

这是因为 Java 语言既具有编译型语言的特征，也具有解释型语言的特征。Java程序首先需要编译成字节码文件，然后JVM类加载器加载字节码后，可以通过解释器逐行解释执行，也可以通过JIT即使编译器完成第一次编译后，其会将字节码对应的机器码保存下来，下次可以直接使用。



##### Java 和 C++ 的区别?

Java 不提供指针来直接访问内存，程序内存更加安全；同时Java 有自动内存管理垃圾回收机制(GC)，不需要程序员手动释放无用内存

Java 的类是单继承的，C++ 支持多重继承；虽然 Java 的类不可以多继承，但是接口可以多继承。。

C ++同时支持方法重载和操作符重载，但是 Java 只支持方法重载（操作符重载增加了复杂性，这与 Java 最初的设计思想不符）。



#####  字符型常量和字符串常量的区别?

字符常量是单引号引起的一个字符，字符串常量是双引号引起的 0 个或若干个字符。

 字符常量相当于一个整型值( ASCII 值),可以参加表达式运算; 字符串常量代表一个地址值(该字符串在内存中存放位置)。

字符常量只占 2 个字节; 字符串常量占若干个字节。



##### 标识符和关键字的区别是什么？

为程序、类、变量等起的名字叫做标识符，而关键字是被赋予特殊含义的标识符，只能用于特殊地方，比如public,new等（true、false、null不是关键字）



##### 静态方法和实例方法有何不同？

静态方法可以使用 类名.方法名 形式调用，不用创建对象，而实例方法使用 对象.方法名 调用，需要创建对象；

静态方法在访问本类的成员时，只允许访问静态变量或方法，不允许访问实例变量或方法，而实例方法不存在这个限制。



##### 重载和重写的区别

重载发生在同一个类或者父类和子类之间，方法名必须相同，参数类型不同、个数不同、顺序不同，方法返回值和访问修饰符可以不同，多个同名方法根据不同的传参来执行不同的逻辑处理（返回值不会对其产生影响）。

重写发生在运行期，是子类对父类的允许访问的方法的实现过程进行重新编写，方法名、参数列表必须相同，子类方法返回值类型应比父类方法返回值类型更小或相等（如果方法的返回类型是 void 和基本数据类型，则返回值重写时不可修改），抛出的异常范围小于等于父类，访问修饰符范围大于等于父类。如果父类方法访问修饰符为 private/final/static 则子类就不能重写该方法，但是被 static 修饰的方法能够被再次声明。（构造方法无法被重写）  



##### 方法签名包含什么？

方法签名由方法名称和一个参数列表（方法的参数的顺序和类型）组成。
注意，方法签名不包括方法的返回类型。不包括返回值和访问修饰符。



#####  == 和 equals() 的区别

Java 只有值传递，因此，对于 == 来说，不管是比较基本数据类型，还是引用数据类型的变量，其本质比较的都是值，只是引用类型变量存的值是对象的地址。

equals()方法存在于Object类中，而Object类是所有类的直接或间接父类，因此所有的类都有equals()方法，子类可以选择重写或者不重写equals()方法。



##### 重写 equals()时必须重写 hashCode() 方法？

hashcode()的作用是获取散列码，可以根据此确定对象在哈希表中的索引位置，Object类的hashcode方法是本地方法，会将对象的内存地址转换为整数之后返回。

 hashCode() 和equals()作用都是用来比较两个对象是否相等

如果hashCode相同的对象，equals为false，向hashSet加入对象的时候，会先通过hashCode的值来判断是否存在重复对象，如果有那么就通过equals方法来判断是否两者是否相等，再进行后续操作。如果重写了equals但是没有重写hashCode()的话，可能会导致多一次的equals判断，效率降低。或者是向map加入对象时，不能将对象均匀地散落到到数组中。

如果本来应该equals的对象，hashcode不同而认为不相等，从而使容器逻辑错误。

（如果两个对象的`hashCode` 值相等，那这两个对象不一定相等，因为会发生哈希碰撞。如果两个对象的`hashCode` 值相等并且`equals()`方法也返回 `true`，我们才认为这两个对象相等。如果两个对象的`hashCode` 值不相等，我们就可以直接认为这两个对象不相等。）



##### 什么是可变长参数？

可变长参数就是允许在调用方法时传入不定长度的参数，方法内可变长参数以数组的形式存在。遇到方法重载时会优先匹配固定参数的方法，因为固定参数的方法匹配度更高。



##### 基本数据类型

Java 中有 8 种基本数据类型，分别为：

1. 6 种数字类型：
   - 4 种整数型：`byte`、`short`、`int`、`long`
   - 2 种浮点型：`float`、`double`
2. 1 种字符类型：`char`
3. 1 种布尔型：` `。



##### 表达式的自动类型转换

byte a = b + 50，有变量，右边计算后会自动提升为int



##### 自动装箱与拆箱了解吗？原理是什么？

java中的八种基本类型都有对应的引用类型

- **装箱**：将基本类型用它们对应的引用类型包装起来；
- **拆箱**：将包装类型转换为基本数据类型；

装箱其实就是调用了 包装类的`valueOf()`方法（Integer.valueOf(10)），拆箱其实就是调用了 `xxxValue()`方法（intvalue()）。

如果频繁拆装箱的话，也会严重影响系统的性能。因此我们应该尽量避免不必要的拆装箱操作。



##### 每种包装对象的值是不可变的，要改变必须重新生成对象



##### 包装类型的常量池技术了解么？

`Byte`,`Short`,`Integer`,`Long` 这 4 种包装类默认创建了数值 **[-128，127]** 的相应类型的缓存数据，`Character` 创建了数值在 **[0,127]** 范围的缓存数据，`Boolean` 直接返回 `True` or `False`。调用对应类的valueOf()创建对象时，如果在范围中，就直接从缓存数据中拿，否则会直接创建对象，



#####  面向对象和面向过程的区别

两者的主要区别在于解决问题的方式不同：

- 面向过程把解决问题的过程拆成一个个方法，通过一个个方法的执行解决问题。
- 面向对象会先抽象出对象，然后用对象执行方法的方式解决问题。

面向对象开发的程序一般更易维护、易复用、易扩展。



##### 面向对象三大特征

封装：把客观事物封装成抽象的类，不允许外部对象直接访问对象的内部信息。但是可以提供一些可以被外界访问的方法来操作。好处是能够隐藏信息、实现等细节，比如性别一般通过1/0存储，不易显示，我们可能通过getter进行修改。同时增加了安全性，比如防止外部类修改private的属性或者访问private方法。

继承：继承是从已有的类中派生出新的类，新的类可以吸收已有的属性、行为，并扩展新的能力。在Java中不支持多继承，单继承使Java的继承关系很简单，一个类只能有一个父类，这样易于我们的管理。通过继承可以提高代码的重用性与可维护性，修改子类的共性时，只需要修改父类的代码，而不需要一个个子类进行修改。

（子类拥有父类对象所有的属性和方法（包括私有属性和私有方法），但是父类中的私有属性和方法子类是无法访问，只是拥有。）

多态：表现为父类的引用指向子类的实例。引用类型变量发出的方法调用的到底是哪个类中的方法，必须在程序运行期间才能确定如果子类重写了父类的方法，真正执行的是子类覆盖的方法，如果子类没有覆盖父类的方法，执行的是父类的方法。（多态不能调用“只在子类存在但在父类不存在”的方法），提高了可扩展性。



#####  成员变量与局部变量的区别有哪些？

从语法形式上看，成员变量是属于类的，而局部变量是在代码块或方法中定义的变量或是方法的参数；成员变量可以被 `public`,`private`,`static` 等修饰符所修饰，而局部变量不能被访问控制修饰符及 `static` 所修饰；但是，成员变量和局部变量都能被 `final` 所修饰。

从变量在内存中的存储方式来看,如果成员变量是使用 `static` 修饰的，那么这个成员变量是属于类的，如果没有使用 `static` 修饰，这个成员变量是属于实例的。属于类的成员变量存在与静态变量池中（jdk6以及之前是在方法区中，jdk7以及之后静态变量池移到了堆里边），属于实例的成员变量随实例存储在堆中；局部变量则存在于栈内存的局部变量表中。 

从变量在内存中的生存时间上看，成员变量是对象的一部分，它随着对象的创建而存在（随类的存在而存在，随类的卸载而卸载），而局部变量随着方法的调用而自动消失。

从变量是否有默认值来看，成员变量如果没有被赋初始值，则会自动以类型的默认值而赋值（一种情况例外:被 `final` 修饰的成员变量也必须显式地赋值），而局部变量则不会自动赋值。



##### 创建一个对象用什么运算符?对象实体与对象引用有何不同?

new 创建对象实例（对象实例在堆内存中），对象引用指向对象实例（对象引用存放在栈内存）。

一个对象引用可以指向 0 个或 1 个对象；一个对象可以有 n 个引用指向它。

对象的相等一般比较的是内存中存放的内容是否相等。

引用相等一般比较的是他们指向的内存地址是否相等



#####  构造方法有哪些特点？是否可被 override?

构造方法特点如下：

- 名字与类名相同。
- 没有返回值，但不能用 void 声明构造函数。
- 生成类的对象时自动执行，无需调用。

构造方法不能被 override（重写）,但是可以 overload（重载）,所以可以看到一个类中有多个构造函数的情况。



##### 接口和抽象类有什么共同点和区别？

都不能被实例化，但是抽象类中可以有构造方法，且能够被子类调用。

都可以包含抽象方法，都可以有默认实现的方法（Java 8 可以用 `default` 关键在接口中定义默认方法）。

接口主要用于对类的行为进行约束，你实现了某个接口就具有了对应的行为。抽象类主要用于代码复用，强调的是所属关系。

一个类只能继承一个类，但是可以实现多个接口（java通过接口实现了多继承）

接口中的成员变量只能是 `public static final`（默认加上） 类型的，不能被修改且必须有初始值，而抽象类的成员变量默认 default（同一类以及同一包中的类可见），可在子类中被重新定义，也可被重新赋值。

接口中的方法，只能是public，可以用abstract或者default或者static修饰；抽象类中没有这个限制。[(15条消息) Java中接口中的方法定义规则_HelloWorld_EE的博客-CSDN博客_接口可以定义什么方法](https://blog.csdn.net/u010412719/article/details/52536233)



##### 深拷贝和浅拷贝区别了解吗？什么是引用拷贝？

**浅拷贝**：浅拷贝会在堆上创建一个新的对象（区别于引用拷贝的一点），不过，如果原对象内部的属性是引用类型的话，浅拷贝会直接复制内部对象的引用地址，也就是说拷贝对象和原对象共用同一个内部对象。

**深拷贝** ：深拷贝会完全复制整个对象，包括这个对象所包含的内部对象。

实现cloneable接口（里边没有东西），并重写Object的clone方法



##### String为什么是不可变的

1.保存字符串的数组被 `final` 修饰且为私有的，并且`String` 类没有提供/暴露修改这个字符串的方法。

2.`String` 类被 `final` 修饰导致其不能被继承，进而避免了子类破坏 `String` 不可变。

`StringBuilder` 与 `StringBuffer` 都继承自 `AbstractStringBuilder` 类，在 `AbstractStringBuilder` 中也是使用字符数组保存字符串，不过没有使用 `final` 和 `private` 关键字修饰，最关键的是这个 `AbstractStringBuilder` 类还提供了很多修改字符串的方法比如 `append` 方法。

每次对 `String` 类型进行改变的时候，都会生成一个新的 `String` 对象，然后将指针指向新的 `String` 对象。`StringBuffer` 每次都会对 `StringBuffer` 对象本身进行操作。

因此String适合操作少量操作；sbuilder和sbuffer适合操作大量数据



##### 线程安全

`StringBuffer` 对方法加了synchronized或者对调用的方法加了synchronized，所以是线程安全的。



##### +与stringbuilder

对象引用和“+”的字符串拼接方式，实际上是通过 `StringBuilder` 调用 `append()` 方法实现的，拼接完成之后调用 `toString()` 得到一个 `String` 对象 。

在循环内使用“+”进行字符串的拼接的话，存在比较明显的缺陷：**编译器不会创建单个 `StringBuilder` 以复用，会导致创建过多的 `StringBuilder` 对象**。

注意，我们左右两边如果是变量的话，就是需要 new StringBuilder 进行拼接，但是如果使用的是 final 修饰，则是从常量池中获取。所以说拼接符号左右两边都是字符串常量或常量引用 则仍然使用编译器优化。



##### 泛型

泛型的本质是参数化类型，也就是说所操作的数据类型被指定为一个参数。

Java 的泛型是伪泛型，这是因为 Java 在运行期间，所有的泛型信息都会被擦掉，这也就是通常所说类型擦除 。

它是通过编译时类型安全检测机制，允许程序员在编译时检测到非法的类型，来实现泛型的。

（泛型类、泛型接口、泛型方法）

[(102条消息) Java 泛型，你了解类型擦除吗？_frank909的博客-CSDN博客_java泛型擦除](https://blog.csdn.net/briblue/article/details/76736356)



##### 反射

原理：堆中的Class对象作为方法区中该类的运行时数据结构的入口，通过他可以在运行时获取类的一些信息。

常见的方法（Java.lang.reflect包下）：Method，Field，Constructor



反射赋予了我们在运行时分析类以及执行类中方法的能力；

反射的优点：动态代理依赖反射，比如动态代理中使用method.invoke()；一些注解的使用也依赖反射，比如@Autowire；

反射的缺点：增加了安全问题，比如可以无视泛型参数的安全检查（因为它发生在编译时），也会无视private的机制。

[面试官你要这么问我Java反射原理，我就笑了 - 知乎 (zhihu.com)](https://zhuanlan.zhihu.com/p/142593317)



##### 注解

注解的本质就是一个继承了 Annotation 接口的接口

元注解：

用来修饰注解的注解，比如@Target指定注解的作用目标，@Retention指定注解的生命周期

注解的生命周期：

- RetentionPolicy.SOURCE：只保留在源文件，注解编译期可见，不会写入 class 文件
- RetentionPolicy.CLASS：会写入 class 文件，类加载阶段丢弃
- RetentionPolicy.RUNTIME：永久保存，可以反射获取

注解只有被解析之后才会生效，常见的解析方法有两种：

- **编译期直接扫描** ：编译器在编译 Java 代码的时候扫描对应的注解并处理，比如某个方法使用`@Override` 注解，编译器在编译的时候就会检测当前的方法是否重写了父类对应的方法。
- **运行期通过反射处理** ：适用于RUNTIME的注解，像框架中自带的注解(比如 Spring 框架的 `@Value` 、`@Component`)都是通过反射来进行处理的。

注解原理：

通过类或方法的getAnnotation获取的是，通过动态代理机制生成一个实现我们注解（接口）的代理类；调用注解的方法，会被AnnotationInvocationHandler的invoke方法拦截，在里边，如果是调用自定义注解声明的方法，将通过方法名，到一个map中找到属性值返回。

[JAVA 注解的基本原理 - Single_Yam - 博客园 (cnblogs.com)](https://www.cnblogs.com/yangming1996/p/9295168.html)





##### 异常

在 Java 中，所有的异常都有一个共同的祖先 `java.lang` 包中的 `Throwable` 类。`Throwable` 类有两个重要的子类:

- **`Exception`** :程序本身可以处理的异常，可以通过 `catch` 来进行捕获。`Exception` 又可以分为 Checked Exception (受检查异常，Java 代码在编译过程中，如果受检查异常没有被 `catch`/`throw` 处理的话，就没办法通过编译 )（比如IO异常，文件未找到异常，classNotFound异常） 和 Unchecked Exception (编译过程中，即使不处理，也能通过编译)（RuntimeException）(比如数组越界异常，算数错误异常)。
- **`Error`** ：`Error` 属于程序无法处理的错误 ，我们没办法通过 `catch` 来进行捕获 。例如虚拟机内存不够错误(`OutOfMemoryError`)、类定义错误（`NoClassDefFoundError`）等 。这些异常发生时，Java 虚拟机（JVM）一般会选择线程终止。

#####  Throwable 类常用方法有哪些？

- `String getMessage()`: 返回异常发生时的简要描述

- `void printStackTrace()`: 在控制台上打印 `Throwable` 对象封装的异常信息

##### try-catch-finally

finally块内的语句在return前会执行， 当 try 语句和 finally 语句中都有 return 语句时，try 语句块中的 return 语句不会被执行。

但是在某些情况下，finally 中的代码不会被执行。比如虚拟机停止，线程死亡或者CPU关闭。

（catch异常时，子类异常需要放在前面，父类异常后面，否则产生编译错误）

（catch可以使用|捕获多个异常，但是形参隐含为final，不能为其赋新值，比如捕获到e，不能用e=新建异常，而捕获单个时可以）

try-catch中有return，finally中修改返回值？

因为return语句会预存返回值。对于基本数据类型，return会直接储存基本数据类型的值；而对于引用变量，预存的是其内存地址。

catch 和 finally 语句块可以省略其中一个，但不可以同时省略。

[(96条消息) try…catch…finally答疑_王球球啊的博客-CSDN博客](https://blog.csdn.net/qq_36737982/article/details/105690931)



##### 什么是序列化?什么是反序列化?如何实现序列化

- **序列化**： 将数据结构或对象转换成二进制字节流的过程
- **反序列化**：将在序列化过程中所生成的二进制字节流转换成数据结构或者对象的过程

**序列化的主要目的是通过网络传输对象或者说是将对象存储到文件系统、数据库、内存中**

实现序列化可以让类实现Serializable接口，然后使用一个输出流来构造一个 ObjectOutputStream(对象流)对象，接着，使用 ObjectOutputStream 对象的 writeObject(Object obj)方法就可以将参数为 obj 的对象写出(即保存其状态)，要恢复的话则用输入流。

##### transient

`transient` 关键字的作用是：阻止实例中那些用此关键字修饰的的变量序列化；当对象被反序列化时，被 `transient` 修饰的变量值不会被持久化和恢复。

`transient` 只能修饰变量，不能修饰类和方法。

反序列化后，其会被置成默认值

static` 变量因为不属于任何对象(Object)，所以无论有没有 `transient` 关键字修饰，均不会被序列化。



#####  Java 中 IO 流分为几种?

- 按照流的流向分，可以分为输入流和输出流；
- 按照操作单元划分，可以划分为字节流和字符流

- 按照流的角色划分为节点流和处理流。（节点流：可以从或向一个特定的地方（节点）读写数据。如FileReader；处理流：是对一个已存在的流的连接和封装，通过所封装的流的功能调用实现数据读写。
  如InputStreamReader ，可以将字节输入流转换为字符输入流。处理流的构造方法总是要带一个其他的流对象做参数）

4种基本的流（抽象类）

- InputStream/Reader: 所有的输入流的基类，前者是字节输入流，后者是字符输入流。
- OutputStream/Writer: 所有输出流的基类，前者是字节输出流，后者是字符输出流。

所有的流都实现了：java.io.Closeable接口，都是可关闭的，都有close()方法。

所有的输出流都实现了：java.io.Flushable接口，都是可刷新的，都有flush()方法。刷新表示将通道/管道当中剩余未输出的数据强行输出完。

##### 字节流与字符流的区别

- 字节流操作的基本单元为字节；字符流操作的基本单元为Unicode码元。字符流是由 Java 虚拟机通过查表将字节转化为 2 个字节的 Unicode 字符为单位的字符而成的。
- 字节流通常用于处理二进制数据，实际上它可以处理任意类型的数据，但它不支持直接写入或读取Unicode码元；字符流通常处理文本数据，它支持直接写入及读取Unicode码元。对Java字符流的操作都是在缓冲区中进行的，因此需要主动flush

##### 字节流如何转为字符流

字节输入流转字符输入流通过 InputStreamReader 实现，该类的构造函数可以传入 InputStream 对象。

字节输出流转字符输出流通过 OutputStreamWriter 实现，该类的构造函数可以传入 OutputStream 对象。

##### NIO、BIO、 AIO之间有什么区别（根据网络的IO回答）

- - BIO：同步阻塞式IO，数据的读取写入必须阻塞在一个线程内等待其完成。适用于连接较少
  - NIO：Java 中的 NIO 可以看作是 I/O 多路复用模型。
    - 同步非阻塞IO，用户进程发起一个IO操作以后边可返回做其它事情，但是用户进程需要时不时的询问IO操作是否就绪。适用于连接较多但连接较短
    - 然而轮询是十分消耗CPU资源的，使用多路复用可以减少无效的系统调用
  - AIO：异步非阻塞IO，用户进程只需要发起一个IO操作然后立即返回，等IO操作真正的完成以后，应用程序会得到IO操作完成的通知，此时用户进程只需要对数据进行处理就好了，不需要进行实际的IO读写操作，因为真正的IO读取或者写入操作已经由内核完成了。适用连接较多且连接较长

##### 既然有了字节流,为什么还要有字符流?

因为字节流转换成字符流，过程很耗时。而且转换时的编码也容易出问题。所以就直接把字符流单独作为了一个部分，将转换交给jvm进行，从而提高使用字符流的效率。

**System.out.println()是什么**

答：println是PrintStream的一个方法，out是一个静态PrintStream类型的成员变量，System是一个java.lang包中的类,用于和底层的操作系统进行交互。

**flush的作用**

带有缓冲区的输出流比如BufferedOutputStream，里边会持有一个数组作为缓冲区，write的时候，不是直接写入文件，而是写入数组，到达规定大小后，再写入文件，也可以不等到达规定大小，调用flush直接刷入文件。



##### Java中只有值传递

值传递 ：方法接收的是实参值的拷贝，对形参修改不影响实参。

引用传递 ：方法接收的直接是实参所引用的对象在堆中的地址，不会创建副本，对形参的修改将影响到实参。

根本区别在于是否会创建副本

java传递基本类型的时候，传递的就是基本类型的字面量值的拷贝，会创建副本。

java在传递引用类型参数中，传递的仍然是值，这个值是实参所引用的对象在堆中地址值的拷贝。在方法中交换形参的值，对实参不会有影响。



##### Java 访问修饰符权限的区别

1. public 所有类都可访问
2. protected 只允许包内、子类访问。
3. 默认 只允许包内访问
4. private 只允许类内访问



##### JAVA的String有长度限制吗？

编译器：CONSTANT_Utf8_info用于标识字符串常量池的值，其中有一个属性length为u2类型，是两个字节的无符号整数；在javac的代码中会检查如果String常量>=65535，报错；

运行期：长度超过Integer.MAX_VALUE会抛异常；



##### 内部类的好处

1.每个内部类都能独立的继承一个类，实现多个接口，内部类使得多继承的解决方案变得完整，

2.方便将存在一定逻辑关系的类组织在一起，又可以对外界隐藏。比如迭代器的实现，

3.方便编写代码，比如匿名内部类，这个类我们只需要实例化一次，因此可以使用匿名内部类。



##### 内部类

成员内部类：可以通过外部类.this访问外部类的变量或方法，不能有静态成员。（编译内部类的代码时，会添加外部类的引用）

局部内部类：与变量低位类似（先声明后使用，。作用域局限于方法或代码块），不能使用访问修饰符，但是更不能使用static（不能包含静态成员）。

匿名内部类：可以访问外部类的变量和方法，但是对于外部方法，只能访问final（会隐式地添加final）

（为了解决生命周期不一致，如果局部变量的值在编译期间就可以确定，则直接在匿名内部里面创建一个拷贝。如果局部变量的值无法在编译期间确定，则通过构造器传参的方式来对拷贝进行初始化赋值，添加final是为了防止数据不一致）

静态内部类：不依赖于外部类，不持有外部类的this引用，但是可以访问外部类的静态成员和方法。可以有自己的静态成员。

[(96条消息) Java内部类详解(使用场景和好处、相关内部类的笔试面试题)_BitHachi-CSDN博客](https://blog.csdn.net/weixin_43914604/article/details/107476943)



##### 动态代理

代理对象来代替对真实对象的访问，这样就可以在不修改原目标对象的前提下，提供额外的功能操作，扩展目标对象的功能。

静态代理需要对目标类额外创建一个代理类来实现对目标的增强，在程序运行前，代理对象的类的.class文件已经存在了。

而动态代理则是在运行时动态生成代理对象的。

##### JDK动态代理

通过`Proxy` 类的 `newProxyInstance()` 创建的代理对象，通过代理对象调用接口方法，实际会调用InvocationHandler的 `invoke()`方法。

##### CGLIB动态代理

[代理详解！静态代理+JDK/CGLIB 动态代理实战 | JavaGuide](https://javaguide.cn/java/basis/proxy.html#_3-1-jdk-动态代理机制)

##### 区别

- jdk动态代理生成的类是一个实现了代理接口的类，它继承了Proxy类，在执行被代理对象的方法时，需要通过反射（每次都得用反射调用一次，所以执行效率不高）；

- cglib动态代理是利用asm，对真实对象的类的字节码进行修改，生成一个子类来实现。代理对象的类继承了真实对象的类，所以真实对象的类或方法最好不要声明成final ，final可以阻止继承和多态。

  编译成class文件时还会额外生成一个fastclass文件，该文件记录了被代理对象各个method的class索引（类名+方法名+参数），当执行某个方法时，通过计算索引，定位到具体的方法（因此他生成类的速度慢）；生成代理对象时通过fastclass索引机制直接定位到被代理对象的class文件，直接拿被代理对象的class内容执行的。因此效率更高。

[JDK 动态代理和Cglib性能对比 - 简书 (jianshu.com)](https://www.jianshu.com/p/eea9a3acbaad)



##### 什么时候用同步/异步

如果数据将在线程间共享，存在资源争夺关系，或者存在合作关系，例如另一个线程等待这个线程的输出。这个时候就需要同步。

当应用程序调用了一个方法，并且不希望让程序等待方法的返回时，就应该使用异步编程，先去做其它没有关联的事情，等方法返回后再继续执行。



##### BigDecimal能够保证精度的原理是什么

不是所有的十进制数都能转化为有限位二进制数的。

1、任意十进制整数可以转化为有限位数的二进制整数。

2、能分解为以(1/2)^n为单位的十进制小数，可以转化为有限位数的二进制小数。

3、上述情形以外的十进制数都不能转化为有限位数的二进制数。

如十进制小数0.7，转化为二进制小数是：0.1011001100110......，循环节是0110。

当第三种情况的小数出现的时候，就会出现计算的精度误差，BigDecimal的原理很简单，就是将小数扩大N倍，转成整数后再进行计算，同时结合指数，得出没有精度损失的结果。
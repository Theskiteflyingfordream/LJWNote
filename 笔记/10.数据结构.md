### 红黑树

自平衡的二叉查找树

1.节点是红色或黑色。

2.根节点是黑色。

3.每个叶子节点都是黑色的空节点（NIL节点）。

4 每个红色节点的两个子节点都是黑色。(从每个叶子到根的所有路径上不能有两个连续的红色节点)

5.从任一节点到其每个叶子的所有路径都包含相同数目的黑色节点。（通过这一点控制平衡）



### 红黑树与AVL树的区别？

- 红黑树要求从根节点到叶子节点的最长路径不大于最短路径的两倍
- AVL 树要求每一个子树的左右孩子节点高度差不超过1



红黑树是牺牲了严格的高度平衡的优越条件为代价红黑树能够以O(log2 n)的时间复杂度进行搜索、插入、删除操作。红黑树的高度要比AVL树更高，而增删结点时，旋转的次数低。

而AVL树的插入和删除时，为了保持平衡，调整的代价大。







### 解决hash冲突的方法

开放地址法、拉链法、重hash法



### 排序算法

快排

堆排序

归并排序

[Java实现归并排序 - 心中的山水 - 博客园 (cnblogs.com)](https://www.cnblogs.com/of-fanruice/p/7678801.html)

希尔排序

基数排序

桶排序

稳定性分析：

[各种排序实现以及稳定性分析 - 追逐更好的自己 - 博客园 (cnblogs.com)](https://www.cnblogs.com/inception6-lxc/p/9021389.html)



堆：

添加元素：插入的元素放到最后，然后依次比较；

删除元素：自底向上堆化（中间出现空位）；自顶向下堆化



### B和B+树的定义



### 动态规划与贪心的原理

前者：

最优子结构：问题的最优解包含了子问题的最优解；

重叠子问题，用递归去解这个问题时，产生的子问题可能是被反复计算过的；

无后效性，指如果在某个阶段上过程的状态已知，则从此阶段以后过程的发展变化仅与此阶段的状态有关，而与过程在此阶段以前的阶段所经历过的状态无关。

后者：

贪心选择性质，动规中，每步做的选择依赖子问题的解，因此自底向上，贪心中，先局部最优选择，再去解决这个选择产生的子问题，自顶向下；

最优子结构





### 图的一些算法（邻接矩阵与邻接表）

##### 最小生成树

prime算法：V和U，V为空集，U为全集，每次选择V到U中边最小的点，将这个点从U并入V；

kruskal算法：初始化每一个点在不同的连通分量上，每次选择代价最小的边，而且边连接了两个不同的连通分量，O（eloge）（并查集）

##### 单源最短路径

迪杰斯特拉算法：

https://www.cnblogs.com/skywang12345/p/3711516.html

FLOYD算法（每一对结点的最短路径）：

https://www.cnblogs.com/skywang12345/p/3711532.html



### KMP





### 赫夫曼殊







### 拓扑排序（判断图无环）

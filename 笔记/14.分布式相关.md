[TOC]

# 什么是分布式系统？

一个分布式系统是一些独立的计算机集合，但是对这个系统的用户来说，系统就像一台计算机一样。

相比传统单体系统的好处在于，能够实现负载均衡，实现高可用。



# 两大理论

**CAP理论**

`一致性 (Consistency)`: 一个写操作返回成功，那么之后的读请求都必须读到这个新数据；如果返回失败，那么所有读操作都不能读到这个数据。所有节点访问同一份最新的数据。

`可用性 (Availability)`: 对数据更新具备高可用性，请求能够及时处理，不会一直等待，即使出现节点失效。

`分区容错性 (Partition tolerance)`: 能容忍网络分区，在网络断开的情况下，被分隔的节点仍能正常对外提供服务。

当发生网络分区的时候，如果我们要继续服务，那么强一致性和可用性只能 2 选 1。也就是说当网络分区之后 P 是前提，决定了 P 之后才有 C 和 A 的选择。

- 如果允许其中一个副本更新，则会导致数据不一致，即丧失了C性质。
- 如果为了保证一致性，将分区某一侧的副本设置为不可用，那么又丧失了A性质。

如果网络分区正常的话（系统在绝大部分时候所处的状态），也就说不需要保证 P 的时候，C 和 A 能够同时保证。



**BASE理论**

对 CAP 中 AP 方案的一个补充。其基本思路就是：通过业务，牺牲强一致性而获得可用性，并允许数据在一段时间内是不一致的，但是最终达到一致性状态。

三要素：

1、基本可用。基本可用是指分布式系统在出现不可预知故障的时候，允许损失部分可用性。但是，这绝不等价于系统不可用。

- 响应时间上的损失: 正常情况下，处理用户请求需要 0.5s 返回结果，但是由于系统出现故障，处理用户请求的时间变为 3 s。
- 系统功能上的损失：正常情况下，用户可以使用系统的全部功能，但是由于系统访问量突然剧增，系统的部分非核心功能无法使用。

2、软状态。指允许系统中的数据存在中间状态（CAP 理论中的数据不一致），并认为该中间状态的存在不会影响系统的整体可用性，即允许系统在不同节点的数据副本之间进行数据同步的过程存在延时。

3、最终一致性。强调的是系统中所有的数据副本，在经过一段时间的同步后，最终能够达到一个一致的状态。因此，最终一致性的本质是需要系统保证最终数据能够达到一致，而不需要实时保证系统数据的强一致性。

[CAP & BASE理论 (javaguide.cn)](https://javaguide.cn/distributed-system/theorem&algorithm&protocol/cap&base-theorem.html#base-理论三要素)



# 分布式事务

**什么是分布式事务？**

在传统项目中，项目由单个服务器和单个数据库部署。这种情况下，数据库本身的事务机制就能保证ACID的原则，这样的事务就叫本地事务。

分布式事务，就是指不是在单个服务或单个数据库架构下，产生的事务。

数据库分库分表

![image-20221120221447440](%E7%94%A8%E5%88%B0%E7%9A%84%E5%9B%BE%E7%89%87/image-20221120221447440.png)

SOA化

![image-20221120221547144](%E7%94%A8%E5%88%B0%E7%9A%84%E5%9B%BE%E7%89%87/image-20221120221547144.png)

以上两种情况都导致要操作的数据库变多了，传统的事务就无法保证操作的一致性，这就需要分布式事务。





## 解决方案：

## 刚性事务（基于CP）

**2PC**

准备阶段：协调者向参与者发起指令，参与者评估自己的状态，如果参与者评估指令可以完成，则会写redo或者undo日志，然后锁定资源，执行操作，但是并不提交。

提交阶段：如果每个参与者明确返回准备成功，则协调者向参与者发起提交指令，参与者提交资源变更的事务，释放锁定的资源；如果任何一个参与者明确返回准备失败（或超时），则协调者向参与者发起中止指令，参与者取消已经变更的事务，执行undo日志，释放锁定的资源。

![image-20221120222620179](%E7%94%A8%E5%88%B0%E7%9A%84%E5%9B%BE%E7%89%87/image-20221120222620179.png)

缺点：

**同步阻塞问题**。在阶段一需要所有的参与者都返回状态后才能进入第二阶段，并且要把相关的全局资源锁定住，这种同步阻塞的操作，会影响整体事务的并发度。

**单点故障**。由于严重的依赖协调者，一旦协调者发生故障，而此时参与者还都处于锁定资源的状态，无法完成事务commit操作。虽然协调者出现故障后，会重新选举一个协调者，可无法解决因前一个协调者宕机导致的参与者处于阻塞状态的问题。

**数据不一致**。在二阶段提交的阶段二中，协调者的commit请求，由于网络分区，导致只有一部分参与者接受到了commit请求，并进行commit，其它参与者没有收到，就导致了数据不一致性的出现。



**3PC**

3PC主要做了两点改进:
1、在协调者和参与者中都引入了超时机制。2PC只有协调者有超时机制，而3PC在参与者内部也加入了超时机制，当参与者各种原因未收到协调者的commit请求后，会对本地事务进行commit，不会一直阻塞等待，解决了2PC的单点故障问题。
2、3PC把2PC的第一个阶段拆分成了两个阶段。划分成了CanCommit、PreCommit和DoCommit三个阶段。询问阶段可以确保尽可能早地发现无法执行操作而需要中止的行为，但是它并不能发现所有这种行为，只会减少这种情况的发生。

![image-20221120224318692](%E7%94%A8%E5%88%B0%E7%9A%84%E5%9B%BE%E7%89%87/image-20221120224318692.png)

3PC并没有解决同步阻塞问题，引入了新的不一致性问题，因此用得少。因为，由于网络原因，协调者发送的abort响应没有及时被参与者接收到，那么参与者在等待超时之后执行了commit操作。这样就和其他接到abort命令并执行回滚的参与者之间存在数据不一致的情况。



## 柔性事务（基于AP）

**TCC**

TCC（Try-Confirm-Cancel）又被称补偿事务，TCC与2PC的思想很相似，事务处理流程也很相似，但2PC是应用于在DB层面，TCC则可以理解为在应用层面的2PC，是需要我们编写业务逻辑来实现。核心是"针对每个操作，都要注册一个与其对应的确认和补偿（撤销）操作"

两个操作：

- 准备阶段(try):资源的检测与预留；
- 执行阶段(commit/cancel):根据上一步结果，判断下面的执行方法，如果上一步中所有事务参与者都成功，则执行commit操作，反之则执行cancel操作。

Confirm和Cancel是只返回成功，不会返回失败。如果由于网络问题，或者服务器临时故障，那么会进行重试，最终成功。

优点（相比于2PC）：

- 通过自动化重试手段，将需要人工处理的不一致情况降到最少。

- 由于在应用层进行事务操作，锁的粒度更加灵活，减少同步阻塞带来的开销

缺点：

- 空回滚：由于在应用层实现的事务逻辑，因此需要处理“空回滚”问题，即没有try，但是cancel。

  解决办法：解决方法就是当主业务发起事务时，生成一个全局事务记录，并生成一个全局唯一ID，贯穿整个事务，再创建一张分支事务记录表，用于记录分支事务，try执行时将全局事务ID和分支事务ID存入分支事务表中，表示执行了try阶段，当cancel执行时，先判断表中是否有该全局事务ID的数据，如果有则回滚，否则不做任何操作。

- 悬挂问题：try请求还未到达对应的服务，因为调用超时了，所以会执行cancel调用，此时cancel已经执行完了，然而这个时候try请求到达了，这个时候执行了try之后就没有后续的操作了，就会导致资源挂起，无法释放。

  解决办法：执行try方法时我们可以借助分支事务表中事务的执行状态，判断confirm或者cancel方法是否执行，如果已经执行了confirm或者cancel那么try就不执行。

- 幂等性：Confirm()和Cancel()的实现必须是幂等的。当这两个操作执行失败时协调者都会发起重试。我们可以在分支事务记录表中增加事务执行状态，每次执行confirm和cancel方法时都查询该事务的执行状态，以此判断事务的幂等性。



**Saga事务**

基于事件：

在基于事件的方式中，第一个服务执行完本地事务之后，会产生一个事件。其它服务会监听这个事件，触发该服务本地事务的执行，并产生新的事件。回滚也是通过服务监听事件并响应实现。

优点：事务各参与方相互之间无直接沟通，完全解耦

缺点：可能产生环形监听

基于命令：

在基于命令的方式中，我们会定义一个新的服务，这个服务扮演的角色就和一支交响乐乐队的指挥一样，告诉各个业务参与方，在什么时候做什么事情。我们管这个新服务叫做协调中心。协调中心通过命令/回复的方式来和Saga中其它服务进行交互。

优点：避免了环形依赖；分布式事务逻辑存在于协调中心，而不是分散在各业务，测试更容易。

缺点：单点故障

**Saga模式建议**

1，给每一个分布式事务创建一个唯一的Tx id。这个唯一的Tx id可以用来在各个业务参与方沟通时精确定位哪一笔分布式事务。

2，对于基于命令的方式，在命令中携带回复地址。这种方式可以让服务同时响应多个协调中心请求。

3，幂等性。幂等性能够增加系统的容错性，让各个业务参与方服务提供幂等性操作，能够在遇到异常情况下进行重试。

4，尽量在命令或者消息中携带下游处理需要的业务数据，避免下游处理时需要调用消息产生方接口获取更多数据。减少系统之间的相互依赖。



**MQ解决分布式事务方案**

将分布式事务拆分成本地事务进行处理

- 本地消息表

  下图中，1和2操作需要包裹在一个事务中，也就是说，保证事务主动方发写业务表数据和写消息表数据的一致性是基于数据库事务的。

<img src="%E7%94%A8%E5%88%B0%E7%9A%84%E5%9B%BE%E7%89%87/image-20230328222940690.png" alt="image-20230328222940690" style="zoom:75%;" />

缺陷：

1）本地消息表与业务耦合在一起，难于做成通用性，不可独立伸缩。

2）本地消息表是基于数据库来做的，而数据库是要读写磁盘IO的，因此在高并发下是有性能瓶颈的

[基于本地消息表的分布式事务解决方案总结 - 知乎 (zhihu.com)](https://zhuanlan.zhihu.com/p/147817106)



- MQ事务方案（将本地消息表放在了MQ中，MQ通过提供2PC的接口，保证事务主动方发写业务表数据和写消息表数据的一致性）

![e8aa3665c57cbe73640057ee51bced65.png](%E7%94%A8%E5%88%B0%E7%9A%84%E5%9B%BE%E7%89%87/e8aa3665c57cbe73640057ee51bced65.png)

![image-20230329143750454](%E7%94%A8%E5%88%B0%E7%9A%84%E5%9B%BE%E7%89%87/image-20230329143750454.png)

![image-20230329143828578](%E7%94%A8%E5%88%B0%E7%9A%84%E5%9B%BE%E7%89%87/image-20230329143828578.png)

**优点**

相比本地消息表方案，MQ 事务方案优点是：

- 消息数据独立存储 ，降低业务系统与消息系统之间的耦合。
- 吞吐量大于使用本地消息表方案。

**缺点**

- 一次消息发送需要两次网络请求(half 消息 + commit/rollback 消息) 。
- 业务处理服务需要实现消息状态回查接口。



**最大努力通知**

进一步优化，在事务主动方增加了消息校对的接口，如果事务被动方没有接收到消息，此时可以调用事务主动方提供的消息校对的接口主动获取。

优化前，事务主动方需要将消息发送出去，并且消息接收方成功接收，这种可靠性发送是由事务主动方保证的；

优化后，事务被动方可以主动调用事务主动方的消息校对接口查询业务消息并消费，通知的可靠性也可以由事务被动方保证的；

![422e83cf0aa5f44462831a845728c560.png](%E7%94%A8%E5%88%B0%E7%9A%84%E5%9B%BE%E7%89%87/422e83cf0aa5f44462831a845728c560.png)

[(17条消息) 对比7种分布式事务方案，还是偏爱阿里开源的Seata，真香！(原理+实战)_不才陈某的博客-CSDN博客](https://blog.csdn.net/qq_34162294/article/details/120984951)



# 一致性算法（多数据副本节点数据一致性）

## 一致性Hash算法

通过hash环和虚拟节点，解决分片场景中，机器添加或下线时的，请求均衡地分散到各个机器的问题。

看pdai

## Paxos算法





## Raft算法





## ZAB算法







# 分布式唯一ID







# 分布式锁





# 分布式会话





# 负载均衡算法

轮询（加权）

随机（加权）

源地址hash

最小连接数法



四层的负载均衡是基于IP和端口实现的，七层的负载均衡是在四层的基础上，基于URL等信息实现



负载均衡解决的问题：

1.解决并发压力，提高应用处理性能（增加吞吐量，加强网络处理能力）；

2.提供故障转移，实现高可用；

3.通过添加或减少服务器数量，提供网站伸缩性（扩展性）；

4.安全防护；（负载均衡设备上做一些过滤，黑白名单等处理）



# 限流算法
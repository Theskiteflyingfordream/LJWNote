### 消息队列的作用

- 通过异步处理提高系统性能（减少响应所需时间）

- 削峰

先将短时间高并发产生的事务消息存储在消息队列中，然后后端服务再慢慢根据自己的能力去消费这些消息，这样就避免直接把后端服务打垮掉。

- 降低系统的耦合性

防止生产者与消费者的直接调用，两者都依赖于消息队列，新增模块或者修改模块就对其他模块影响较小，提高了扩展性。



### 主题模式

主题模式是指，发布者将消息发送到指定主题中，订阅者需要提前订阅主题才能接受特定主题的消息，Kafka，RabbitMQ，RocketMQ等都是按照这个去实现的。

在普通的单个队列中，一条消息只能被一个消费者消费，无法实现广播，因此它是没法用于主题模式的实现。

**Kafka主题模式的实现：**

- 单个队列中，每个消费者组维护一个offset，来实现一个消息能够被多个消费组的消费者消费。


![image-20221105011425833](%E7%94%A8%E5%88%B0%E7%9A%84%E5%9B%BE%E7%89%87/image-20221105011425833.png)

- 同时一个Topic可以拥有多个队列，这些队列可以分布在不同的Broker，从而实现负载均衡。
  - 生产者根据策略将消息推到这个Topic的某一个分区下面；
  - 消费者组中的消费者们订阅相同的Topic；同一时刻，一个Topic中的队列只能被消费者中的一个消费者消费；保证这个消费者组将Topic中的所有队列消费

https://www.cnblogs.com/cjsblog/p/9664536.html



### Kafka中zookeeper的作用

- 注册Broker
- 注册消费者
- 维护Topic中分区及与Broker的对应关系
- 生产者负载均衡：使生产者的消息合理地发送到这些分布式的Broker上
- 消费者的负载均衡：维护分区与消费者组中的消费者的关系

[(15条消息) Kafka中Zookeeper的作用_一只慵懒的猫z的博客-CSDN博客_zookeeper在kafka中的作用](https://blog.csdn.net/peng_2297731313/article/details/124099789)





### 消息队列如何保证顺序消费？

**Kafka：**

- 生产者发送消息到不同的分区，会导致乱序，而同一个分区中消息是有序的，因此发送消息时可以指定分区或key（会根据key作hash到分区）。

- 消费者消费消息时，如果开多线程，会导致乱序，比如同一个订单号的不同消息，被多个线程处理，可能乱序，因此对同一类消息，需要单线程处理。



### 消息队列如何保证消息不丢？

**丢失有以下三种情况：**

- 生产者发送的消息因为网络原因丢失；

- Kafka宕机丢消息（Kafka 为分区引入了多副本机制。分区中的多个副本之间会有一个叫做 leader 的家伙，其他副本称为 follower。生产消费者只与leader交互，follower 副本用作备份，从 leader 副本中拉取消息进行同步。如果leader挂了，消息没有同步到follower也会导致丢消息）；

- 消费端消费完消息之前就提交了offset，消费的过程中挂了，导致丢消息；

**Kafka的解决策略：**

- 生产者不能在调用send()之后，就认为发送成功，可以通过回调函数，当失败时，通过重试机制去重新send
- 设置参数来保证消息不丢失：
  - 给topic设置 replication.factor 参数，这个值必须大于1，表示要求每个partition必须至少有2个副本。
  - 在kafka服务端设置 min.isync.replicas>1，这样配置代表消息至少要被写入到 2 个副本才算是被成功发送（当acks=all/-1才有效）
  - 在生产者端设置 acks=all ，表示只有所有 ISR 列表（里边不包含宕机的）的副本全部收到消息时，生产者才会接收到来自服务器的成功响应。
  - 设置 unclean.leader.election.enable = false。当 leader 副本发生故障时就不会从 follower 副本中和 leader 同步程度达不到要求的副本中选择出 leader ，这样降低了消息丢失的可能性
  - 为配合上述参数，生产者端需要有重试机制。
- 手动关闭自动提交 offset，每次在真正消费完消息之后再自己手动提交 offset 。 但是，这样会带来消息被重新消费的问题。比如你刚刚消费完消息之后，还没提交 offset，结果自己挂掉了，那么这个消息理论上就会被消费两次。



### 消息队列推和拉两种模式

**推模式：**

推模式指的是消息从 Broker 推向 Consumer，即 Consumer 被动的接收消息，由 Broker 来主导消息的发送。

优点：实时性高、消费者使用简单

缺点：推送速率难以适应消费速率、身为 Broker 很难平衡每个消费者的推送速率

**拉模式：**

拉模式指的是 Consumer 主动向 Broker 请求拉取消息，即 Broker 被动的发送消息给 Consumer。

优点：消费者可以根据自身的情况来发起拉取消息的请求（可以批量发送）、Broker轻松

缺点：消息延迟、消息忙请求（忙请求就是比如消息隔了几个小时才有，那么在几个小时之内消费者的请求都是无效的，在做无用功）



Kafka用的是拉模式，使用“长轮询”机制。通过消费者等待消息，当有消息的时候 Broker 会直接返回消息，如果没有消息都会采取延迟处理的策略，并且为了保证消息的及时性，在对应队列或者分区有新消息到来的时候都会提醒消息来了，及时返回消息。

https://segmentfault.com/a/1190000023854950



### 消息队列如何保证不重复消费？

kafka出现消息重复消费的原因：服务端侧已经消费的数据没有成功提交 offset；

解决方案：消费服务做幂等校验，比如 Redis 的set、MySQL 的主键等天然的幂等功能。这种方法最有效。



### 死信队列？

![image-20221105155946298](%E7%94%A8%E5%88%B0%E7%9A%84%E5%9B%BE%E7%89%87/image-20221105155946298.png)



### Kafka为什么速度快？

- 顺序写入。每一个Partition其实都是一个文件 ，收到消息后Kafka会把数据插入到文件末尾，顺序写入的消息读取也是顺序的，借助OS的一些优化（页缓存，预读，write back），减少了实际IO的频率 以及 磁盘寻道的时间。

- 网络IO使用零拷贝提高性能
- 网络传输过程中使用批量压缩以及批量发送
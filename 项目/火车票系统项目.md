列车信息（列车号，起始站id，终点站id，时间）

经停站信息（列车号，到达顺序，到达时间，停留时间，出发时间，价格）

座位表（日期，列车号，用数字表示的区间，binary串表示的座位状态（从当前站到下一站，1表示有人坐，0表示没人坐））



如何找余票？

首先从数据库中，

然后根据传入的起始站和终点站，找到分别在经停站信息的下标，然后从起始站到终点站，将每一列的byte相或，放到result[]中，比如这一行的byte[0]或下一行的byte[0]，最后为了提高计算result[]数组中的1的个数，对每8个byte，使用Long.bitCount计算，剩下不足8个的，每4个用bitCount计算，最后不足4个的，每个byte计算，所有计算结果的和就是余票。



如何占坐？

首先开一个事务

同样按照上面的方法得到result[]数组后，遍历每一位，依次将下标取余%5，分类ABCDE类座位放入集合中，然后然后遍历用户要求类别，对于每个座位开一个事务处理。在处理中用update更新它，然后根据返回的受影响行数判断是否成功，如果受影响行数与预期的不符合的话，说明这个过程中有人修改了它，那么手动抛出异常，回滚，进行下一个座位的判断。

如何取消订单？

取消订单不需要开启事务，只要构造一个byte，置对应的位为1，其它为0，然后一个update语句异或就行了。



改善：

第一个：

binary串对应的字段，存的东西十分多，导致锁的粒度大，把它拆分成多个座位区间，用不同的行存储。得到总的binary串之后，在update前，可以根据用户的id做hash，使得不同类的用户更新的是不同区间里边的，失败再去找其它的区间更新，冲突就减少了。

第二个：

用redis做缓存，redis中刚好有个bitmap数据结构能和binary串那个字段对应上，把更新多行数据写到lua脚本中一次执行，lua脚本大概逻辑是，判断几行的对应位置都为0后，置1。然后redis中的数据异步更新到数据库中，提高了吞吐量。

第三个：

在网上的一些文章中，我看到了座位表可以这样设计，每一行存的是某个日期的某一趟车的某个座位，然后加了两个属性，分别是起始站和终止站，表示这个座位被占的最小起始站和最大终止站。

求余票：

比如，求某一个日期某趟列车在（1，3）这个区间的余票的时候，只需要找日期和列车号对应，并且（起始站值，终止站值）这个区间与（1，3）没有重合的座位，再统计个数。

抢票要占某个座位时，只需要把起始站和终止站的字段更新，更新的那条语句加个where起始站和终止站符合条件的，这样锁的粒度极大地减小，同时也不需要像位图的设计那样要回滚。

但是对比位图来说，这种座位表的设计，会导致整张表十分大，因为每个座位都占了一行，而单一个日期中的一趟列车，座位数量就可能有几百个甚至上千个。



（X）

用到的索引：

座位表中用列车号座位主键，然后列车号和日期和区间做一个索引。



难点是座位表的设计

因为座位表不仅要考虑到每一个位，也要考虑到每一个站，



缺点：

并没有用自增id作为主键，而是用列车号作为主键；

并没有使用缓存。


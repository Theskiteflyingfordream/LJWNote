# 分布式锁是什么？

首先，锁是用来实现多个线程对共享资源的互斥访问，可以将锁理解成一个标记，这个标记每个线程都能看到，访问共享资源的时候，线程根据这个标记判断自己能否访问。
很关键的一个地方在于，这个标记要让每个线程都能看到。
在单进程系统中，将这个标记可以放到进程的堆中。
而在分布式系统中，多个进程中的线程需要看到这个标记，这些进程甚至在不同的机器上，因此就需要将标记存放到公共的内存，比如redis上面，这就是分布式锁与普通的锁的最大区别。

而对这个标记的不同维护方案产生了分布式锁的不同实现



# 问题？

在北向文件导出的问题中，我的排查步骤是，先到代码中找与分布式锁相关的日志输出，然后通过grep过滤日志，发现任务是周期触发的，但是出现了6小时内都获取锁失败的异常情况。

再进一步定位到异常情况前的最后一个上锁操作的日志，发现这个上锁的线程有某一行之后的日志都没打印，正常上锁应该打印的，于是我定位到了打印对应日志的代码，就是那个区间出了问题，后来导师和我说是因为在那个区间里，获取redis连接异常，导致的，而这个异常被捕获，导致上锁的线程退出了，而没有释放锁。

进一步地，通过我们的代码，我了解到了分布式锁中的看门狗这个东西：

首先，为了防止在执行任务的过程中，上锁的线程所在的进程挂了，分布式锁永远不会释放，在上锁的时候，会通过expire设置锁的存活时间，这样即使上锁的线程所在的进程挂了，锁也能自动释放；然而这样就会出现一个问题，任务执行得比较久，在执行完之前，锁就过期了，这样其他任务就能够获得锁，从而导致错误，因此需要一个看门狗线程给分布式锁续命，在线程释放锁的时候，再把这个看门狗线程取消掉。



# 与redisson的对比

**1、存储形式不同**

- 在我们的代码中，锁在redis中存储形式为，“只与锁类型相关，与上锁的线程和进程无关”的key，以及Random生成的伪随机数作为value。
- Redisson中，锁在redis中存储形式为Hash结构，key是由业务侧决定的锁名，field是uuid（区别不同进程，同一个ConnectionManager中uuid相同）+线程ID（区别同一进程中的线程），value表示上锁的次数。

这也直接导致了互斥以及可重入功能的实现不同

**2、互斥功能的实现不同**

上锁的互斥（只有一个进程中的一个线程能够上锁）

- 通过set nx实现了互斥

- 上锁使用了lua脚本。。。。

释放锁的互斥（线程释放自己上的锁，其他线程上的锁不能释放）

不同进程的线程：

在成功上锁后，会把key和value（上锁的时候随机生成）放进randIdsMap，解锁的时候再

同一进程的不同线程：

**3、重入功能**

- 通过set nx加锁，一旦加了锁，释放前不能再加，因此不支持重入

- 根据上面提到的锁的存储结构，通过value表示重入次数，支持重入；

  因为支持重入，每次重入counter++，在释放锁的时候，判断是否能把看门狗取消；同时看门狗线程中，根据counter判断是否要续命

**4、lock()失败**

- 会自旋trylock()+sleep获取执行锁。

- 同样是自旋获取，获取失败的时候，如果剩余过期时间>=0，会调用信号量的tryacquire()等待一段时间再自旋，小于0（key不存在或者没有设置过期时间，此时自旋浪费资源）则调用信号量的acquire()直接阻塞；由于在之前已经订阅“锁释放”消息，当其他线程释放锁的时候，会广播释放锁消息；收到后，回调方法会被调用，释放对应的信号量。

  redissonLock的好处在于获取锁失败后，可以通过本地的信号量判断是否能够到redis上加锁；而RedisDistrbuteLock加锁失败后需要频繁地发送命令到redis中执行，如果等待锁的线程十分多，会为redis带来不必要的压力，同时会有网络IO带来的开销。

**5、公平锁实现**

- 非公平，北向文件导出中，使用两把锁，一把排队锁，一把执行锁

- 公平锁用的是RedissonFairLock这个类，继承了RedissonLock，基本逻辑保持不变，主要是上锁和释放锁的lua脚本改变了。

  它使用了redis中的两个数据结构实现了排队与公平，分别是list和zset；每个锁都有一个对应的list和zset

  list是作为先入先出的队列，存的是uuid+线程名；

  zset中存的是<uuid+线程名, 超时时间>的键值对，这个超时时间主要是用来防止线程下线了，却一直卡在队列中，导致后面的线程没法获取锁；



# 思考

能否引进redisson或者使用类似的设计去优化我们的分布式锁设计？

直接引进是不行的，因为在我们的转储与北向文件导出分布式锁使用中，上锁的线程与执行任务（释放锁）的线程是不一致的，这是为了使用异步，上锁成功了，不用等待任务执行，直接返回任务执行成功；然而redis存储结构中filed是需要与线程关联的

因此为了引进redisson需要使上锁与执行任务（释放锁）的线程一致，而又为了实现异步，我想到了一个设计。

就是外部线程与上锁执行任务的线程共享一个标识，一旦上锁的线程上完锁，就修改标识，外部线程访问到标识修改后，直接返回。

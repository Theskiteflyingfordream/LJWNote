我先来讲一下对团队项目的理解，我们做的是一个网元告警的接收、处理、存储、展示、推送的分布式系统，计算组负责的主要是接收、存储和推送，然后我在实习期间，主要是学习了告警接收那部分的一些设计。

首先，一个最简单的模型就是告警添加了全局唯一csn等信息后，经过前置处理放入缓存，再由后面的推送部分操作，缓存中的信息由异步线程入库。

这样显然是不行的，为了提高吞吐量，需要使用多线程处理。我们使用了分片作为并行的最小粒度，告警根据设备标识hash到不同的分片中。

前置处理这个耗时的操作可以使用多线程进程，同时可以使用redis队列将前置处理与告警接入进行解耦，redis队列也起到了削峰的作用。上报过程中，节点将告警放到redis队列就可以直接返回，由当前节点或者其它节点开线程去轮询redis队列取数据。

与redis通信需要网络IO，同时redis通信是采用TCP的请求响应模型，请求完阻塞等待服务端响应，因此需要在本地引入一个内存队列将接入与推送到redis队列解耦，接入的线程只需要把告警放到内存队列就返回，这样有效地对突发流量进行削峰；而从内存队列推送到redis队列可以开多线程进行。

这是接入那块的一些基本设计。



其中还有几个点我想讲一下，

首先是上面提到的多线程的实现，它其实是将线程分为两类，有一个是专门分派任务的线程，一类是专门处理任务的，这样就实现了各司其职，提高效率。

然后是有序性，同一个设备的告警不能被乱序处理，然而多个节点或多线程可能会导致乱序的出现，我们是通过同一分片的有序实现同一设备的有序的。对于多线程，使用countdownlatch控制，在同一批中，一个分片只被某一个线程处理，等到他们都执行完再进行分配下一批任务，对于多节点，设备的告警只能上报给固定的服务进程处理，同时，redis中存储了节点与分片的映射关系，每个节点只能从redis队列中获取自己管辖的分片的告警进行处理。

最后是全局csn的实现，我们的数据库只有一个master，在某一行中存储着当前最大的csn，某个节点分配csn给告警时，需要cas将这一行增加一段值，成功后，表示这一段值，是这个节点可以分配给告警的。



一些思考：

在有序性这一点中，使用countdownlatch会导致这样一种情况，即使后续来的告警存在于不同的分片中，它的执行会受阻与上一批中处理得最慢的那个分片，我想到得一个优化就是将countdownlatch改成对不同分片的本地的锁。

全局唯一ID可以使用类似雪花算法的做法，这样就不需要多个节点去抢这一行。

并行的粒度是分片，是否可以更细化成网元。



我先来讲一下对团队项目的理解，我们做的是一个网元告警的接收、处理、存储、展示、推送的分布式系统，计算组负责的主要是接收、存储和推送，然后我在实习期间，主要是学习了告警接收那部分的一些设计。

首先我们的数据库做了分表，对表进行横向拆分，不同的告警会依据一定策略放到不同的表里边，分表的好处在于减少表的大小，进行一些操作能够更快。

基于此，一个最简单的模型就是告警添加了分片信息和全局唯一csn等信息后，经过前置处理放入缓存，再由后面的推送部分操作，缓存中的信息由异步线程入库。

但是前置处理的过程十分耗时，，同时它是可以并行的，因此这里应该用多线程进行，同时可以将前置处理与告警接入进行的解耦。这是使用redis队列实现的，上报过程中，节点将告警放到redis队列就可以直接返回，由当前节点或者其它节点开线程去轮询redis队列取数据。

然而告警的突发流量可能十分大，同时与redis通信需要网络IO，同时redis通信是采用TCP的请求响应模型，请求完阻塞等待服务端响应，因此需要在本地引入一个内存队列将接入与推送到redis队列解耦，接入的线程只需要把告警放到内存队列就返回，这样有效地对突发流量进行削峰；而从内存队列推送到redis队列可以开多线程进行。

这是接入那块的一些基本设计。



其中还有几个点我想讲一下，

首先是上面提到的多线程的实现，它其实是将线程分为两类，有一个是专门分派任务的线程，一类是专门处理任务的，这样就实现了各司其职，提高效率。

然后是有序性，同一设备的告警不能被乱序处理，然而多个节点或多线程可能会导致乱序的出现，在我们的设计中，解决方案是，对于多节点，设备的告警只能上报给固定的服务进程处理，对于多线程，分派任务线程将不同分片的任务分派给不同进程，再countdownlatch阻塞，等到他们都执行完再进行分配下一批任务。

最后是全局csn的实现，我们的数据库只有一个实例，在某一行中存储着当前最大的csn，某个节点分配csn给告警时，需要cas将这一行增加一段值，成功后，表示这一段值，是这个节点可以分配给告警的。（为啥不用雪花算法？）



一些思考：

在有序性这一点中，使用countdownlatch会导致这样一种情况，即使后续来的告警存在于不同的分片中，它的执行会受阻与上一批中处理得最慢的那个分片，我想到得一个优化就是将countdownlatch改成对不同分片的本地的锁。

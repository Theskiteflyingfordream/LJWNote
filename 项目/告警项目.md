我先来讲一下对团队项目的理解，我们做的是一个网元告警的接收、处理、存储、展示、推送的分布式系统，计算组负责的主要是接收、存储和推送，然后我在实习期间，主要是学习了告警接收那部分的一些设计。

首先我们的数据库做了分表，对表进行横向拆分，不同的告警会依据一定策略放到不同的表里边，分表的好处在于减少表的大小，进行一些操作能够更快。

基于此，一个最简单的模型就是告警添加了分片信息和全局唯一csn等信息后，经过前置处理放入缓存，再由后面的推送部分操作，缓存中的信息由异步线程入库。

但是前置处理的过程十分耗时，同时它是可以并行的，因此这里应该用多线程进行，这样就需要引入redis队列进行前置处理与告警接入的解耦。（为什么是redis队列，而不是内存队列？）

然而告警的突发流量可能十分大，同时与redis通信需要网络IO，同时redis通信是采用TCP的请求响应模型，请求完阻塞等待服务端响应，因此需要在本地引入一个内存队列将接入与推送到redis队列解耦，接入的线程只需要把告警放到内存队列就返回，这样有效地对突发流量进行削峰；而从内存队列推送到redis队列可以开多线程进行。

这是接入那块的一些基本设计。



其中还有几个点我想讲一下，

首先是上面提到的多线程的实现，它其实是将线程分为两类，有一个是专门分派任务的线程，一类是专门处理任务的，这样就实现了各司其职，提高效率。

然后是有序性，（job机制？每一个job里边的告警是有序的？）

最后是全局csn的实现，我们的数据库只有一个实例，在某一行中存储着当前最大的csn，某个节点分配csn给告警时，需要cas将这一行增加一段值，成功后，表示这一段值，是这个节点可以分配给告警的。（为啥不用雪花算法？）
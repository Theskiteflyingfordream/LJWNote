jwt实现登录
用户登录的时候，首先在数据库中找出user，如果存在，那么就根据id生成一个token，以token为key把user存到redis中，然后把token返回；往后用户每次请求都先拿出token，到redis中找user，并把user放到全局threadLocal中；退出登录的时候，只需要把redis中对应的key删除就行了；
这里提到的将suer放到全局的threadLocal是通过springmvc的拦截器干的，是因为防止在一次请求之内频繁地从redis中拿，threadLocal也保证了线程的隔离，同时在请求处理完之后，拦截器将threadLocal中的用户信息删除，防止内存泄漏。

阅读量增加
用户第一次查看文章详情的时候，会判断redis中有没有对应的key存储阅读量，如果没有就set，有的话就自增（通过lua脚本）；然后有一个定时任务定期把阅读量set进去；
（write back模式，提高了吞吐量）

统一缓存
在方法上加一个自定义注解，这样就表示开启缓存，有一个AOP的切点类，配置了环绕通知，在controller的方法执行前，以类名+方法名+方法参数作为key，到redis中找，找到就返回，没找到就执行方法，然后把结果作为value设置到redis中，并返回；文章更新的时候，publish的时候，会想消息队列发送一个articleId的消息，消费者收到消息的时候，会把缓存给删除；
（cache aside模式，保证了一致性）
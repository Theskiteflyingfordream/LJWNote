回顾项目

排序算法



https://zhuanlan.zhihu.com/p/59256821

笔记线程报错的处理逻辑；

CAS和锁分别适合什么场景
总结javaguide中地jwt地优缺点；看https://www.zhihu.com/question/274566992



面试问题：

mybatis

Linux查看内存使用率以及cpu指令的命令

MySQL的多表查询（笛卡尔积）

SQL注入的几种场景

CAP理论



虚拟内存有哪些段（牛客C++操作系统八股）

vector和ArrayList的区别

hashmap的实现（什么时候会退化成树？）

回顾select和epoll的区别

Arrays.sort()的原理，元素少时用冒泡快还是快排好





线程池中的队列的作用是什么？

redis为什么这么快

简历：redis做队列有什么坏处？https://cloud.tencent.com/developer/article/1819027

使用一致性hash解决分片负载不均衡的问题？

redis的发布-监听的可靠性是如何实现的？



# 容器化相关的待整理：

**基于隧道的方案（Flannel的UDP和VXLAN）：**

**UDP：**

一台宿主机上的所有容器，都属于该宿主机的一个子网

画图（IP包）（docker0到flannel0设备：路由表；flanneld进程封成UDP（etcd保存了子网与宿主机的关系，目标地址通过查etcd得到）：查路由表经过eth0发出去））

缺点：存在较多上下文切换（画图）

**VXLAN：**

与UDP相比，完全在内核态实现封装和解封装

画图（IP包）（docker0到VETP设备：路由表；VETP设备找目标容器的VETP设备IP，进而找到mac（一个节点加入Flannel网络后，所有flannled进程会为所在节点在一条路由，以及一条ARP记录），然后打上mac封装成帧，再打上VXLAN标识（表示目的宿主机收到后，拆包后交给VETP设备处理），再根据flannled进程维护的FDB数据库，找到目的VETP设备的宿主机的IP，然后封成UDP，再根据自学习的ARP找到MAC，封成帧，根据路由通过eth0发出去；）



**基于修改路由表的方案（Flannel的host-gw、Calico）：**

同样使用网桥，基于修改宿主机的路由表实现，这个表由宿主机的flanneld进程维护，要求网络二层连通；

Calico：不使用网桥，通过BGP间交换信息来维护路由表（图）；当集群规模大时，使用的是Route Reflector模式，它指定一个或专门几个节点，来与所有节点建立BGP连接，维护路由表，其它节点只需要跟这几个专门的节点交换信息（图）（由于二层不连通，所以需要使用隧道（当然也可以修改链路上的网关的路由，但是在公有云的场景下不适用））；



**我们的网络实现方案：**





**容器的存储：**

绑定挂载与挂载

UnionFS（K8S 07 08）
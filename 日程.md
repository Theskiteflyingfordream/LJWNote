- 分布式锁是什么（什么是分布式？）

首先，锁是用来实现多个线程对共享资源的互斥访问，可以将锁理解成一个标记，这个标记每个线程都能看到，访问共享资源的时候，线程根据这个标记判断自己能否访问。
很关键的一个地方在于，这个标记要让每个线程都能看到。
在单进程系统中，将这个标记可以放到进程的堆中。
而在分布式系统中，多个进程中的线程需要看到这个标记，这些进程甚至在不同的机器上，因此就需要将标记存放到公共的内存，比如redis上面，这就是分布式锁与普通的锁的最大区别。

而对这个标记的不同维护方案产生了分布式锁的不同实现



- 我们代码释放锁互斥那里，可以怎么改？

我觉得一种比较合适的改法是，上锁的线程与执行任务的线程应该一致，同时修改redis的锁的存储结构为类似redisson那样的hash结构，这样就能够保证了释放锁的互斥，同时在阈值转储和手工转储中也不需要第二把锁的存在。

但是我还没搞清楚代码中，执行任务的线程    设计成与   上锁的线程   不一致的特殊用意是什么，所以目前还不是很清楚这个方案是否合适。



- 

redisson公平锁的实现；

公平锁用的是RedissonFairLock这个类，继承了RedissonLock，基本逻辑保持不变，主要是上锁和释放锁的lua脚本改变了。

它使用了redis中的两个数据结构实现了排队与公平，分别是list和zset；每个锁都有一个对应的list和zset

list是作为先入先出的队列，存的是uuid+线程名；

zset中存的是<uuid+线程名, 超时时间>的键值对，这个超时时间主要是用来防止线程下线了，却一直卡在队列中，导致后面的线程没法获取锁；

https://juejin.cn/post/6973991797672378382



改进：北向文件导出也用了两把锁，一把执行锁，一把排队锁，如果一致有





- redlock简介

  https://zhuanlan.zhihu.com/p/59256821；https://cloud.tencent.com/developer/article/1602970

RedLock算法思想是，不能只在一个redis的master实例上创建锁，应该有多个redis的master，并在它们上面加锁

当在大多数master节点上都成功创建锁，才能算这个整体的RedLock加锁成功。

Redisson中的RedLock是通过RedissonMutiLock实现的，这个东西主要是将多个RedissonLock合并成一个大锁，统一地上锁解锁。

这一块没有细看，就不深入介绍了。





算法：hot100 79

八股：看到redis








https://zhuanlan.zhihu.com/p/59256821

笔记线程报错的处理逻辑；

CAS和锁分别适合什么场景
总结javaguide中地jwt地优缺点；看https://www.zhihu.com/question/274566992

